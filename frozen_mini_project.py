# -*- coding: utf-8 -*-
"""Frozen mini project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wto1nZTM1DeQKOFt8Ny8GsAO9gDbplAz
"""

def greet(name):
  print('hello,',name)

  greet("alice")
  greet("bob")

#civil - concrete mix value calculation
def concrete_volume(length,width,thickness):
  return length*width*thickness
print("concrete_volume:",(10,5,0.2),"m*m*m")

import math
def rlc_impedence(R,L,C,f):
  XI=2*math.pi*f*L
  Xc=1/(2*math.pi*f*c)
  return MATH.SQRT(r**2+(XI-XC)**2)
  R=100
  L=0.5
  C=1e-6
  f=50
  print("RLC circuit impedence",rlc_impedence(R,L,C,f),)

import math
def three_phase_power(v_line,I_line,power_)

import numpy as np
arr=np.array([1,2,3])
print(arr)

class Motor:
  def __init__(self,power_kw,efficiency):
    self.power_kw=power_kw
    self.efficiency=efficiency
  def output_power(self):
      return self.power_kw*self.efficiency
motor1=Motor(10,0.92)
print(motor1.output_power())

"""DAY-9"""

import json
with open('machine_config.ison')as f:
  config=json.load(f)
  print(config['motor']['rated_speed'])

try:
  data=float(input('enter load value:'))
except ValueError:
  print('Invalid input!enter a number')

class Address:
  def __init__(self,street,city,state):
    self.street=street
    self.city=city
    self.state=state
s1 = Address("kvr petrol bank","rajampet","ap")
print("s1.street:",s1.street)
print("s1.city:",s1.city)
print("s1.state:",s1.state)

from scipy.optimize import fsolve
def eq(x):
  return 3*x**2-x-1
root=fsolve(eq,0)
print("root:",root)

"""DAY-7

PENDINGS
"""

def beam_ids(n):
  for i in range(1,n+1):
    yield f"B{i}"
    for beam in beam_ids(3):
        print(beam)

"""program-1"""

import math
print("circle area:",math.pi*0.1*2)

"""sc-2"""

beam_id="B12"
length_m=5.5
is_safe=True
materials=["steel","concrete"]
print("beam_id:",beam_id)
print("length_m:",length_m)
print("is_safe:",is_safe)
print("materials:",materials)

"""                      monte carlo simulation
                      realiabiltiy and safety factor
"""

import numpy as np
samples=np.random.normal(50,5,10000)
failure_rate=np.mean(samples>60)
print(failure_rate*100,'%')

"""                                    data fitting
                                    fit experimental data to models
                             
"""

import numpy as np
from scipy.optimize import curve_fit
def model(x,a,b):
    return a*np.exp(b*x)
x=np.linespace(0,4,50)
y=model(x,2,0.5)+np.random.normal(0,0.2,50)
popt_=curve_fit(model,x,y)
print(popt)

"""                          Tkinter GUI
                          build calculators for engineering
"""

import tkinter as tk
def calc():
  F=float(entry_force.get())
  A=float(entry_area.get())
  result.set(F/A)
root=tk.Tk()
entry_force=tk.Entry(root)
entry_area=tk.Entry(root)
result=tk.StringVar()
tk.Button=(root,textvariable=result)

import pandas as pd
df=pd.read_excel('data.x|sx')
df['stress']=df['Force']/df['Area']

"""# Task
Model the charging and discharging behavior of a Li-ion battery for EV battery management systems using numpy and matplotlib, taking capacity, current, and voltage as inputs and outputting state of charge (SOC) and efficiency.
"""

import numpy as np
import matplotlib.pyplot as plt

class LiionBattery:
    def __init__(self, capacity_Ah, initial_soc, voltage_V, charging_efficiency=0.95, discharging_efficiency=0.95):
        if not 0 <= initial_soc <= 1:
            raise ValueError("Initial SOC must be between 0 and 1")
        self.capacity_Ah = capacity_Ah
        self.soc = initial_soc
        self.voltage_V = voltage_V
        self.charging_efficiency = charging_efficiency
        self.discharging_efficiency = discharging_efficiency

    def update_soc(self, current_A, time_step_h):
        """Updates the battery's state of charge."""
        if current_A > 0:  # Charging
            charge_change_Ah = current_A * time_step_h * self.charging_efficiency
        else:  # Discharging
            charge_change_Ah = current_A * time_step_h / self.discharging_efficiency

        self.soc += charge_change_Ah / self.capacity_Ah
        self.soc = max(0, min(1, self.soc)) # Ensure SOC stays within [0, 1]


    def get_current_voltage(self):
        """Returns the current voltage (simplified model assumes constant voltage)."""
        return self.voltage_V

    def calculate_efficiency(self, current_A):
        """Calculates efficiency based on current (simplified model assumes constant efficiency)."""
        if current_A > 0: # Charging
            return self.charging_efficiency
        elif current_A < 0: # Discharging
            return self.discharging_efficiency
        else: # No current
            return 1.0

# 1. Define the total simulation time and the time step
total_time_h = 10  # Total simulation time in hours
time_step_h = 0.1  # Time step in hours
num_steps = int(total_time_h / time_step_h)

# 2. Create an instance of the LiionBattery class
battery = LiionBattery(capacity_Ah=50, initial_soc=0.5, voltage_V=350)

# 3. Initialize lists to store simulation results
time_list = []
soc_list = []
current_list = []
voltage_list = []
efficiency_list = []

# 4. Loop through the simulation time
for i in range(num_steps):
    current_time = i * time_step_h

    # Define the current at the current time step
    # Example: Charging for the first half, discharging for the second half
    if current_time < total_time_h / 2:
        current_A = 20  # Charging current
    else:
        current_A = -15  # Discharging current


    # Update the battery's state
    battery.update_soc(current_A, time_step_h)
    current_voltage = battery.get_current_voltage()
    current_efficiency = battery.calculate_efficiency(current_A)

    # Append results to lists
    time_list.append(current_time)
    soc_list.append(battery.soc)
    current_list.append(current_A)
    voltage_list.append(current_voltage)
    efficiency_list.append(current_efficiency)

# Create a figure and a set of subplots
fig, axes = plt.subplots(2, 1, figsize=(10, 8))

# Plot SOC over time
axes[0].plot(time_list, soc_list)
axes[0].set_xlabel('Time (h)')
axes[0].set_ylabel('State of Charge (SOC)')
axes[0].set_title('Battery State of Charge over Time')

# Plot efficiency over time
axes[1].plot(time_list, efficiency_list)
axes[1].set_xlabel('Time (h)')
axes[1].set_ylabel('Efficiency')
axes[1].set_title('Battery Efficiency over Time')

# Adjust layout and display plots
plt.tight_layout()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

class LiionBattery:
    def __init__(self, capacity_Ah, initial_soc, voltage_V, charging_efficiency=0.95, discharging_efficiency=0.95):
        if not 0 <= initial_soc <= 1:
            raise ValueError("Initial SOC must be between 0 and 1")
        self.capacity_Ah = capacity_Ah
        self.soc = initial_soc
        self.voltage_V = voltage_V
        self.charging_efficiency = charging_efficiency
        self.discharging_efficiency = discharging_efficiency

    def update_soc(self, current_A, time_step_h):
        """Updates the battery's state of charge."""
        if current_A > 0:  # Charging
            charge_change_Ah = current_A * time_step_h * self.charging_efficiency
        else:  # Discharging
            charge_change_Ah = current_A * time_step_h / self.discharging_efficiency

        self.soc += charge_change_Ah / self.capacity_Ah
        self.soc = max(0, min(1, self.soc)) # Ensure SOC stays within [0, 1]


    def get_current_voltage(self):
        """Returns the current voltage (simplified model assumes constant voltage)."""
        return self.voltage_V

    def calculate_efficiency(self, current_A):
        """Calculates efficiency based on current (simplified model assumes constant efficiency)."""
        if current_A > 0: # Charging
            return self.charging_efficiency
        elif current_A < 0: # Discharging
            return self.discharging_efficiency
        else: # No current
            return 1.0

# 1. Define the total simulation time and the time step
total_time_h = 10  # Total simulation time in hours
time_step_h = 0.1  # Time step in hours
num_steps = int(total_time_h / time_step_h)

# 2. Create an instance of the LiionBattery class
battery = LiionBattery(capacity_Ah=50, initial_soc=0.5, voltage_V=350)

# 3. Initialize lists to store simulation results
time_list = []
soc_list = []
current_list = []
voltage_list = []
efficiency_list = []

# 4. Loop through the simulation time
for i in range(num_steps):
    current_time = i * time_step_h

    # Define the current at the current time step
    # Example: Charging for the first half, discharging for the second half
    if current_time < total_time_h / 2:
        current_A = 20  # Charging current
    else:
        current_A = -15  # Discharging current


    # Update the battery's state
    battery.update_soc(current_A, time_step_h)
    current_voltage = battery.get_current_voltage()
    current_efficiency = battery.calculate_efficiency(current_A)

    # Append results to lists
    time_list.append(current_time)
    soc_list.append(battery.soc)
    current_list.append(current_A)
    voltage_list.append(current_voltage)
    efficiency_list.append(current_efficiency)

# Create a figure and a set of subplots
fig, axes = plt.subplots(2, 1, figsize=(10, 8))

# Plot SOC over time
axes[0].plot(time_list, soc_list)
axes[0].set_xlabel('Time (h)')
axes[0].set_ylabel('State of Charge (SOC)')
axes[0].set_title('Battery State of Charge over Time')

# Plot efficiency over time
axes[1].plot(time_list, efficiency_list)
axes[1].set_xlabel('Time (h)')
axes[1].set_ylabel('Efficiency')
axes[1].set_title('Battery Efficiency over Time')

# Adjust layout and display plots
plt.tight_layout()
plt.show()

